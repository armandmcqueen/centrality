# AUTOGENERATED FILE DO NOT EDIT

from typing import cast, Any
import datetime
from sqlalchemy import Index
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column
from controlplane.datastore.types.metrics.metric import (
    MetricBaseORM,
    MetricLatestBaseORM,
    MetricBaseModel,
    MetricLatestBaseModel,
)
from pydantic import BaseModel, Field


metric_name = "disk_iops"
# example disk_iops metrics: {disk1: iopsXXX, disk2: iopsYYY}
metric_shape_db = dict[str, float]


# Custom Types


class DiskIops(BaseModel):
    disk_name: str = Field(..., description="The name of the disk, e.g. /dev/sda.")
    iops: float = Field(..., description="The IOPS for the disk.")


# Convert metrics column in DB to object fields as dict that can be passed to super().from_orm() as kwargs
def convert_from_metrics(
    metrics: dict[str, float],
) -> dict[str, dict[str, DiskIops]]:
    iops: dict[str, DiskIops] = {
        device: DiskIops(disk_name=device, iops=iops_val)
        for device, iops_val in metrics.items()
    }
    return dict(iops=iops)


# Convert user-facing object fields to metrics column shape in DB
def convert_to_metrics(self: Any) -> dict[str, float]:
    return {disk_name: iops.iops for disk_name, iops in self.iops.items()}


class DiskIopsMetricLatestORM(MetricLatestBaseORM):
    __tablename__ = "machine_metric_disk_iops_latest"
    metrics: Mapped[dict[str, float]] = mapped_column(JSONB, nullable=False)


class DiskIopsMetricORM(MetricBaseORM):
    __tablename__ = "machine_metric_disk_iops"
    metrics: Mapped[dict[str, float]] = mapped_column(JSONB, nullable=False)

    __table_args__ = (
        Index("idx_metric_disk_iops_ts", "ts"),  # Creating the index
        Index(
            "idx_metric_disk_iops_machine_id_ts", "machine_id", "ts"
        ),  # Composite index
    )


class DiskIopsMetricLatest(MetricLatestBaseModel):
    machine_id: str
    ts: datetime.datetime
    iops: dict[str, DiskIops] = Field(
        ...,
        description="A dict of IOPS for each disk. Each disk will have an entry in the dict with the disk name as the key.",
    )

    @classmethod
    def from_orm(cls, orm: DiskIopsMetricLatestORM, **kwargs) -> "DiskIopsMetricLatest":
        instance = super().from_orm(orm=orm, **convert_from_metrics(orm.metrics))
        return cast(DiskIopsMetricLatest, instance)

    def to_disk_iops_measurement(self) -> "DiskIopsMeasurement":
        kwargs = self.model_dump()
        return DiskIopsMeasurement(**kwargs)


class DiskIopsMetric(MetricBaseModel):
    metric_id: str
    machine_id: str
    ts: datetime.datetime
    iops: dict[str, DiskIops] = Field(
        ...,
        description="A dict of IOPS for each disk. Each disk will have an entry in the dict with the disk name as the key.",
    )

    @classmethod
    def from_orm(cls, orm: DiskIopsMetricORM, **kwargs) -> "DiskIopsMetric":
        instance = super().from_orm(orm=orm, **convert_from_metrics(orm.metrics))
        return cast(DiskIopsMetric, instance)

    def to_disk_iops_measurement(self) -> "DiskIopsMeasurement":
        kwargs = self.model_dump()
        kwargs.pop("metric_id")
        return DiskIopsMeasurement(**kwargs)


class DiskIopsMeasurement(BaseModel):
    """
    A measurement of DiskIops
    """

    # This is the user-facing object that is sent to and from the REST endpoint
    machine_id: str = Field(
        ..., description="The machine_id of the machine that generated this measurement"
    )
    ts: datetime.datetime = Field(..., description="The timestamp of the measurement")
    iops: dict[str, DiskIops] = Field(
        ...,
        description="A dict of IOPS for each disk. Each disk will have an entry in the dict with the disk name as the key.",
    )

    def to_metrics(self) -> dict[str, float]:
        return convert_to_metrics(self)
