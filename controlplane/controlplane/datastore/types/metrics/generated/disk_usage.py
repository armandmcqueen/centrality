# AUTOGENERATED FILE DO NOT EDIT

from typing import cast, Any
import datetime
from sqlalchemy import Index
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column
from controlplane.datastore.types.metrics.metric import (
    MetricBaseORM,
    MetricLatestBaseORM,
    MetricBaseModel,
    MetricLatestBaseModel,
)
from pydantic import BaseModel


metric_name = "disk_usage"
# example disk_usage metrics: {disk1: [used, total], disk2: [used, total]}
metric_shape_db = dict[str, list[float]]


# Custom Types
class DiskUsage(BaseModel):
    disk_name: str
    used_mb: float
    total_mb: float


# Convert metrics column in DB to object fields as dict that can be passed to super().from_orm() as kwargs
def convert_from_metrics(
    metrics: dict[str, list[float]],
) -> dict[str, list[DiskUsage]]:
    usage: list[DiskUsage] = [
        DiskUsage(disk_name=disk, used_mb=usage_vals[0], total_mb=usage_vals[1])
        for disk, usage_vals in metrics.items()
    ]
    return dict(usage=usage)


# Convert user-facing object fields to metrics column shape in DB
def convert_to_metrics(self: Any) -> dict[str, list[float]]:
    return {usage.disk_name: [usage.used_mb, usage.total_mb] for usage in self.usage}


class DiskUsageMetricLatestORM(MetricLatestBaseORM):
    __tablename__ = "machine_metric_disk_usage_latest"
    metrics: Mapped[dict[str, list[float]]] = mapped_column(JSONB, nullable=False)


class DiskUsageMetricORM(MetricBaseORM):
    __tablename__ = "machine_metric_disk_usage"
    metrics: Mapped[dict[str, list[float]]] = mapped_column(JSONB, nullable=False)

    __table_args__ = (
        Index("idx_metric_disk_usage_ts", "ts"),  # Creating the index
        Index(
            "idx_metric_disk_usage_machine_id_ts", "machine_id", "ts"
        ),  # Composite index
    )


class DiskUsageMetricLatest(MetricLatestBaseModel):
    machine_id: str
    ts: datetime.datetime
    usage: list[DiskUsage]

    @classmethod
    def from_orm(
        cls, orm: DiskUsageMetricLatestORM, **kwargs
    ) -> "DiskUsageMetricLatest":
        instance = super().from_orm(orm=orm, **convert_from_metrics(orm.metrics))
        return cast(DiskUsageMetricLatest, instance)

    def to_disk_usage_measurement(self) -> "DiskUsageMeasurement":
        kwargs = self.model_dump()
        return DiskUsageMeasurement(**kwargs)


class DiskUsageMetric(MetricBaseModel):
    metric_id: str
    machine_id: str
    ts: datetime.datetime
    usage: list[DiskUsage]

    @classmethod
    def from_orm(cls, orm: DiskUsageMetricORM, **kwargs) -> "DiskUsageMetric":
        instance = super().from_orm(orm=orm, **convert_from_metrics(orm.metrics))
        return cast(DiskUsageMetric, instance)

    def to_disk_usage_measurement(self) -> "DiskUsageMeasurement":
        kwargs = self.model_dump()
        kwargs.pop("metric_id")
        return DiskUsageMeasurement(**kwargs)


class DiskUsageMeasurement(BaseModel):
    """
    A measurement of DiskUsage
    """

    # This is the user-facing object that is sent to and from the REST endpoint
    machine_id: str
    ts: datetime.datetime
    usage: list[DiskUsage]

    def to_metrics(self) -> dict[str, list[float]]:
        return convert_to_metrics(self)
